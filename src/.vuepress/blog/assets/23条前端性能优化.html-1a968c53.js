import{_ as t,F as i,V as h,W as c,$ as r,a1 as o,Z as l,Y as e,X as a,a0 as d}from"./framework-fd1dac66.js";const p={},_=a("h1",{id:"前端性能优化是个巨大的课题-如果要面面俱到的说的话-估计三天三夜说不完。所以我们就从实际的工程应用角度出发-聊我们最常遇见的前端优化问题。",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#前端性能优化是个巨大的课题-如果要面面俱到的说的话-估计三天三夜说不完。所以我们就从实际的工程应用角度出发-聊我们最常遇见的前端优化问题。","aria-hidden":"true"},"#"),e("       前端性能优化是个巨大的课题，如果要面面俱到的说的话，估计三天三夜说不完。所以我们就从实际的工程应用角度出发，聊我们最常遇见的前端优化问题。")],-1),u=d(`<p>尽量合并图片、CSS、JS。比如加载一个页面，如果有5个css文件的话，那么会发出5次http请求，这样会让用户第一次访问你的页面的时候会长时间等待。而如果把这个5个文件合成一个的话，就只需要发出一次http请求，节省网络请求时间，加快页面的加载。</p><h2 id="_2-使用cdn" tabindex="-1"><a class="header-anchor" href="#_2-使用cdn" aria-hidden="true">#</a> 2. 使用CDN</h2><p>网站上静态资源即css、js全都使用cdn分发，图片亦然。</p><h2 id="_3-避免空的src和href" tabindex="-1"><a class="header-anchor" href="#_3-避免空的src和href" aria-hidden="true">#</a> 3. 避免空的src和href</h2><p>当link标签的href属性为空、script标签的src属性为空的时候，浏览器渲染的时候会把当前页面的URL作为它们的属性值，从而把页面的内容加载进来作为它们的值。所以要避免犯这样的疏忽。</p><h2 id="_4-为文件头指定expires" tabindex="-1"><a class="header-anchor" href="#_4-为文件头指定expires" aria-hidden="true">#</a> 4. 为文件头指定Expires</h2><p>Exipres是用来设置文件的过期时间的，一般对css、js、图片资源有效。 他可以使内容具有缓存性，这样下回再访问同样的资源时就通过浏览器缓存区读取，不需要再发出http请求。如下例子：新浪微博的这个css文件的Expires时间是2016-5-04 09:14:14</p><h2 id="_5-使用gzip压缩内容" tabindex="-1"><a class="header-anchor" href="#_5-使用gzip压缩内容" aria-hidden="true">#</a> 5. 使用gzip压缩内容</h2><p>gzip能够压缩任何一个文本类型的响应，包括html，xml，json。大大缩小请求返回的数据量。</p><h2 id="_6-把css放到顶部" tabindex="-1"><a class="header-anchor" href="#_6-把css放到顶部" aria-hidden="true">#</a> 6. 把CSS放到顶部</h2><p>网页上的资源加载时从上网下顺序加载的，所以css放在页面的顶部能够优先渲染页面，让用户感觉页面加载很快。</p><h2 id="_7-把js放到底部" tabindex="-1"><a class="header-anchor" href="#_7-把js放到底部" aria-hidden="true">#</a> 7. 把JS放到底部</h2><p>加载js时会对后续的资源造成阻塞，必须得等js加载完才去加载后续的文件 ，所以就把js放在页面底部最后加载。</p><h2 id="_8-避免使用css表达式" tabindex="-1"><a class="header-anchor" href="#_8-避免使用css表达式" aria-hidden="true">#</a> 8. 避免使用CSS表达式</h2><p>举个css表达式的例子</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>font-color:expression((new Date()).getHours()%3 ? &quot;#fff&quot; : &quot;#aaa&quot;);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个表达式会持续的在页面上计算样式，影响页面的性能。并且css表达式只被IE支持。</p><h2 id="_9-将css和js放到外部文件中" tabindex="-1"><a class="header-anchor" href="#_9-将css和js放到外部文件中" aria-hidden="true">#</a> 9. 将CSS和JS放到外部文件中</h2><p>目的是缓存文件，可以参考原则4。 但有时候为了减少请求，也会直接写到页面里，需根据PV和IP的比例权衡。</p><h2 id="_10-权衡dns查找次数" tabindex="-1"><a class="header-anchor" href="#_10-权衡dns查找次数" aria-hidden="true">#</a> 10. 权衡DNS查找次数</h2><p>减少主机名可以节省响应时间。但同时，需要注意，减少主机会减少页面中并行下载的数量。IE浏览器在同一时刻只能从同一域名下载两个文件。当在一个页面显示多张图片时，IE 用户的图片下载速度就会受到影响。所以新浪会搞N个二级域名来放图片。</p><p>1.精简CSS和JS 这里就涉及到css和js的压缩了。比如下面的新浪的一个css文件，把空格回车全部去掉，减少文件的大小。现在的压缩工具有很多，基本主流的前端构建工具都能进行css和js文件的压缩，如grunt，glup等。</p><h2 id="_12-避免跳转" tabindex="-1"><a class="header-anchor" href="#_12-避免跳转" aria-hidden="true">#</a> 12. 避免跳转</h2>`,23),b={href:"http://baidu.com",target:"_blank",rel:"noopener noreferrer"},f={href:"http://baidu.com/",target:"_blank",rel:"noopener noreferrer"},x={href:"http://baidu.com/bbs",target:"_blank",rel:"noopener noreferrer"},m={href:"http://bbs.baidu.com/",target:"_blank",rel:"noopener noreferrer"},g=d(`<h2 id="_13-删除重复的js和css" tabindex="-1"><a class="header-anchor" href="#_13-删除重复的js和css" aria-hidden="true">#</a> 13. 删除重复的JS和CSS</h2><p>重复调用脚本，除了增加额外的HTTP请求外，多次运算也会浪费时间。在IE和Firefox中不管脚本是否可缓存，它们都存在重复运算JavaScript的问题。</p><h2 id="_14-配置etags" tabindex="-1"><a class="header-anchor" href="#_14-配置etags" aria-hidden="true">#</a> 14. 配置ETags</h2><p>它用来判断浏览器缓存里的元素是否和原来服务器上的一致。比last-modified date更具有弹性，例如某个文件在1秒内修改了10次，Etag可以综合Inode(文件的索引节点(inode)数)，MTime(修改时间)和Size来精准的进行判断，避开UNIX记录MTime只能精确到秒的问题。 服务器集群使用，可取后两个参数。使用ETags减少Web应用带宽和负载</p><h2 id="_15-可缓存的ajax" tabindex="-1"><a class="header-anchor" href="#_15-可缓存的ajax" aria-hidden="true">#</a> 15. 可缓存的AJAX</h2><p>异步请求同样的造成用户等待，所以使用ajax请求时，要主动告诉浏览器如果该请求有缓存就去请求缓存内容。如下代码片段, cache:true就是显式的要求如果当前请求有缓存的话，直接使用缓存</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>$.ajax({
  url : &#39;url&#39;,
  dataType : &quot;json&quot;,
  cache: true,
  success : function(son, status){},
  error : function(){}
})
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_16-使用get来完成ajax请求" tabindex="-1"><a class="header-anchor" href="#_16-使用get来完成ajax请求" aria-hidden="true">#</a> 16. 使用GET来完成AJAX请求</h2><p>当使用XMLHttpRequest时，浏览器中的POST方法是一个“两步走”的过程：首先发送文件头，然后才发送数据。因此使用GET获取数据时更加有意义。</p><h2 id="_17-减少dom元素数量" tabindex="-1"><a class="header-anchor" href="#_17-减少dom元素数量" aria-hidden="true">#</a> 17. 减少DOM元素数量</h2><p>这是一门大学问，这里可以引申出一堆优化的细节。想要具体研究的可以看后面推荐书籍。总之大原则减少DOM数量，就会减少浏览器的解析负担。</p><h2 id="_18-避免404" tabindex="-1"><a class="header-anchor" href="#_18-避免404" aria-hidden="true">#</a> 18. 避免404</h2><p>比如外链的css、js文件出现问题返回404时，会破坏浏览器的并行加载。</p><h2 id="_19-减少cookie的大小" tabindex="-1"><a class="header-anchor" href="#_19-减少cookie的大小" aria-hidden="true">#</a> 19. 减少Cookie的大小</h2><p>Cookie里面别塞那么多东西，因为每个请求都得带着他跑。</p><h2 id="_20-使用无cookie的域" tabindex="-1"><a class="header-anchor" href="#_20-使用无cookie的域" aria-hidden="true">#</a> 20. 使用无cookie的域</h2><p>比如CSS、js、图片等，客户端请求静态文件的时候，减少了 Cookie 的反复传输对主域名的影响。</p><h2 id="_21-不要使用滤镜" tabindex="-1"><a class="header-anchor" href="#_21-不要使用滤镜" aria-hidden="true">#</a> 21. 不要使用滤镜</h2><p>IE独有属性AlphaImageLoader用于修正7.0以下版本中显示PNG图片的半透明效果。这个滤镜的问题在于浏览器加载图片时它会终止内容的呈现并且冻结浏览器。在每一个元素（不仅仅是图片）它都会运算一次，增加了内存开支，因此它的问题是多方面的。 完全避免使用AlphaImageLoader的最好方法就是使用PNG8格式来代替，这种格式能在IE中很好地工作。如果你确实需要使用AlphaImageLoader，请使用下划线_filter又使之对IE7以上版本的用户无效。</p><h2 id="_22-不要在html中缩放图片" tabindex="-1"><a class="header-anchor" href="#_22-不要在html中缩放图片" aria-hidden="true">#</a> 22. 不要在HTML中缩放图片</h2><p>比如你需要的图片尺寸是50* 50，那就不用用一张500*500的大尺寸图片，影响加载（说到这里可能有朋友会说了，后台上传的图片我也没办法控制他上传的尺寸啊，这里只是说的最开始做静态页面的时候的一些注意事项，至于后面怎么去操作，那就看网编怎么办了，尽可能把自己能做的做到最好就行了）</p><h2 id="_23-缩小favicon-ico并缓存" tabindex="-1"><a class="header-anchor" href="#_23-缩小favicon-ico并缓存" aria-hidden="true">#</a> 23. 缩小favicon.ico并缓存</h2><p>以上是Yslow的23个优化原则，基本可以涵盖现在前端大部分的性能优化原则了，很多更加geek和精细优化方法都是从这些原则里面延伸出来的。</p><p>前端优化是条漫长的路，不是说一天两天就能全部做完的。我们可以参考上面的准则去把我们目前能做的都给优化了，剩下的更加小的一些细节点不用太过着急，毕竟也是要考虑优化性价比的。比如为了减小一个文件几个字节花上个把月根本不值得。这些优化的东西都可以在我们的工作中慢慢去通过积累，去通过google解决。</p>`,24);function v(S,j){const n=i("center"),s=i("ExternalLinkIcon");return h(),c("div",null,[r(n,null,{default:o(()=>[_]),_:1}),l(" more "),e(" ## 1. 减少HTTP请求次数 ## "),u,a("p",null,[e("有种现象会比较坑爹，看起来没什么差别，其实多次了一次页面跳转。比如当URL本该有斜杠（/）却被忽略掉时。例如，当我们要访问 http:// "),a("a",b,[e("baidu.com"),r(s)]),e(" 时，实际上返回的是一个包含301代码的跳转，它指向的是 http:// "),a("a",f,[e("baidu.com/"),r(s)]),e(" （注意末尾的斜杠）。在nginx服务器可以使用rewrite；Apache服务器中可以使用Alias 或者 mod_rewrite或者the DirectorySlash来避免。 另一种是不用域名之间的跳转， 比如访问 http:// "),a("a",x,[e("baidu.com/bbs"),r(s)]),e(" 跳转到 http:// "),a("a",m,[e("bbs.baidu.com/"),r(s)]),e(" 。那么可以通过使用Alias或者mod_rewirte建立CNAME（保存一个域名和另外一个域名之间关系的DNS记录）来替代。")]),g])}const k=t(p,[["render",v],["__file","23条前端性能优化.html.vue"]]);export{k as default};
